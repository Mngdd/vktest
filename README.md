### по коду
объекты умирают при *достижении* ttl - т.е. если сейчас 0я секунда и ttl стоит 5, 
то объект считается мертвым уже на пятой секунде.

gtest тянется симейком через скачивание
### асимптотика
n - кол-во ВСЕХ ключей (как активных, так и просроченных) \
конструктор очевидно работает за линию
- set - log(n)
- remove - log(n)
- get - log(n)
- getManySorted - n
- removeOneExpiredEntry - log(n)

можно было бы усложнить код в разы чтоб получить **get** и **getManySorted** за O(1), 
но все же log(n) даже при максимальном значении uint64_t дает не сильный отрыв от константы.

### оверхед

На одну запись оверхед приходится из **kv_map_** и **expiration_set_**.
Строка весит 32 байта, uint64_t - 8 байт.
- ***kv_map_***: ключ->строка + значение->timedKVMember(строка + uint64_t) +
на поддержание структуры к/ч дерева уйдет около 32 байт (зависит от компилятора) \
    **ИТОГО:** 32+32+8+32=104 байта
- ***expiration_set_***: аналогично значение->timedSetMember(строка + uint64_t) +
  на поддержание структуры к/ч дерева уйдет около 32 байт (зависит от компилятора) \
  **ИТОГО:** 32+8+32=72 байта 

надо еще вычесть размеры 2х строк (ключ-значение которые дали изначально).
#### всего на одну запись оверхед составит ~112 байт
можно было добиться еще меньшего значения, сохраняя например в set ключ не строкой, а указателем, 
но это наверное не так критично